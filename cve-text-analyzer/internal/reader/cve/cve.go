package cve

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/bmatcuk/doublestar/v4"
	"github.com/facebookincubator/nvdtools/wfn"

	"github.com/anchore/go-sync"
	"github.com/anchore/grype-db/pkg/provider/unmarshal/nvd/cvss31"
	cpee "github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cpe"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

type cveVersion struct {
	Version     string `json:"version"`
	VersionType string `json:"versionType"`
	LessThan    string `json:"lessThan"`
}

type cveAffected struct {
	Vendor      string       `json:"vendor"`
	Product     string       `json:"product"`
	PackageName string       `json:"packageName"`
	Versions    []cveVersion `json:"versions"`
	Cpes        []string     `json:"cpes"`
}

type cveMetadata struct {
	ID    string `json:"cveId"`
	State string `json:"state"`
}

type cveReference struct {
	Url string `json:"url"`
}

type cveText struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type cveMetrics struct {
	cvss31.Cvss31 `json:"cvssV3_1"`
}

type cveCna struct {
	Affected     []cveAffected  `json:"affected"`
	References   []cveReference `json:"references"`
	Descriptions []cveText      `json:"descriptions"`
	Metrics      []cveMetrics   `json:"metrics"`
}

type cveContainers struct {
	Cna cveCna `json:"cna"`
}

type cveRecord struct {
	CveMetadata cveMetadata   `json:"cveMetadata"`
	Containers  cveContainers `json:"containers"`
}

func getSingleVendorProduct(affected []cveAffected) string {
	out := ""
	for _, a := range affected {
		cpeVendorProduct := getSingleCpeVendorProduct(a.Cpes)
		if out != "" && out != cpeVendorProduct {
			// there really shouldn't be multiple _different_ vendor products, we won't know the right one to use
			return ""
		}
		out = cpeVendorProduct
	}
	return out
}

func getSingleCpeVendorProduct(cpes []string) string {
	out := ""
	// if there are CPEs explicitly defined, use those
	for _, c := range cpes {
		cpe, _ := wfn.Parse(fmt.Sprintf("%v", c))
		if cpe == nil {
			continue
		}
		cpeVendorProduct := cpee.ToVendorProduct(cpe)
		if out != "" && out != cpeVendorProduct {
			// there really shouldn't be multiple _different_ cpes, we won't know the right one to use
			return ""
		}
		out = cpeVendorProduct
	}
	return out
}

func ReadFiles(executor sync.Executor, glob string) []Rec {
	paths := util.Get(doublestar.FilepathGlob(glob))

	collector := sync.NewCollector[[]Rec](executor)
	for _, p := range paths {
		p := p
		collector.Provide(func() []Rec {
			return readCveFile(p)
		})
	}
	knownRecords := util.MergeAll(collector.Collect())

	return knownRecords
}

func readCveFile(cveFile string) []Rec {
	var cveRec cveRecord
	util.Log(json.Unmarshal(util.Get(os.ReadFile(cveFile)), &cveRec))

	if cveRec.CveMetadata.State == "REJECTED" {
		// skip rejected CVEs, as they may be wrong or just have no data
		return nil
	}

	if cveRec.CveMetadata.ID == "" {
		util.Log("no cveId in:", cveFile)
		return nil
	}

	cveID := NormalizeCve(cveRec.CveMetadata.ID)

	var text []string

	for _, description := range cveRec.Containers.Cna.Descriptions {
		if description.Lang == "en" {
			text = append(text, description.Value)
		}
	}

	for _, reference := range cveRec.Containers.Cna.References {
		url := reference.Url
		if url != "" {
			text = append(text, url)
		}
	}

	if len(text) == 0 {
		util.Log("no usable Text in: ", cveFile)
		return nil
	}

	// if there's a single, known vendorProduct CPE, return only one entry with it
	singleVendorProduct := getSingleVendorProduct(cveRec.Containers.Cna.Affected)
	if singleVendorProduct != "" {
		// append any additional vendor/product Text we can find since they all reference "the same" product; it'll be deduplicated later
		for _, a := range cveRec.Containers.Cna.Affected {
			text = append(text, a.Vendor, a.Product, a.PackageName)
		}
		return []Rec{{
			Cpe:  singleVendorProduct,
			Cve:  cveID,
			Text: text,
		}}
	}

	// we don't have a single known vendorProduct CPE, so include a record for the CPE Text, which may be matched to a single CPE later
	for _, a := range cveRec.Containers.Cna.Affected {
		// if we found a CPE, skip this record; we have multiple CPEs and don't know the right one
		if len(a.Cpes) > 0 {
			continue
		}
		// also include any known affected product Text we find
		text = append(text, a.Vendor, a.Product, a.PackageName)
	}

	// if we return
	return []Rec{{
		Cpe:  "", // this record does not have a known vendorProduct CPE
		Cve:  cveID,
		Text: text,
	}}
}
