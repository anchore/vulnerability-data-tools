package cve

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/bmatcuk/doublestar/v4"
	"github.com/facebookincubator/nvdtools/wfn"

	"github.com/anchore/go-sync"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cpe"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

func ReadSingleVendorProducts(executor sync.Executor, glob string) []Rec {
	paths := util.Get(doublestar.FilepathGlob(glob))

	collector := sync.NewCollector[[]Rec](executor)
	for _, p := range paths {
		p := p
		collector.Provide(func() []Rec {
			return readCveFile(p)
		})
	}
	knownRecords := util.MergeAll(collector.Collect())

	return knownRecords
}

func readCveFile(cveFile string) []Rec {
	var cveRec Record
	util.Log(json.Unmarshal(util.Get(os.ReadFile(cveFile)), &cveRec))

	if cveRec.Metadata.State == "REJECTED" {
		// skip rejected CVEs, as they may be wrong or just have no data
		return nil
	}

	if cveRec.Metadata.ID == "" {
		util.Log("no cveId in:", cveFile)
		return nil
	}

	cveID := NormalizeCve(cveRec.Metadata.ID)

	var text []string

	for _, description := range cveRec.Containers.Cna.Descriptions {
		if description.Lang == "en" {
			text = append(text, description.Value)
		}
	}

	for _, reference := range cveRec.Containers.Cna.References {
		url := reference.Url
		if url != "" {
			text = append(text, url)
		}
	}

	if len(text) == 0 {
		util.Log("no usable Text in: ", cveFile)
		return nil
	}

	// if there's a single, known vendorProduct CPE, return only one entry with it
	singleVendorProduct := getSingleVendorProduct(cveRec.Containers.Cna.Affected)
	if singleVendorProduct != "" {
		// append any additional vendor/product Text we can find since they all reference "the same" product; it'll be deduplicated later
		for _, a := range cveRec.Containers.Cna.Affected {
			text = append(text, a.Vendor, a.Product, a.PackageName)
		}
		return []Rec{{
			Cpe:  singleVendorProduct,
			Cve:  cveID,
			Text: text,
		}}
	}

	// we don't have a single known vendorProduct CPE, so include a record for the CPE Text, which may be matched to a single CPE later
	for _, a := range cveRec.Containers.Cna.Affected {
		// if we found a CPE, skip this record; we have multiple CPEs and don't know the right one
		if len(a.Cpes) > 0 {
			continue
		}
		// also include any known affected product Text we find
		text = append(text, a.Vendor, a.Product, a.PackageName)
	}

	// if we return
	return []Rec{{
		Cpe:  "", // this record does not have a known vendorProduct CPE
		Cve:  cveID,
		Text: text,
	}}
}

func getSingleVendorProduct(affected []Affected) string {
	out := ""
	for _, a := range affected {
		cpeVendorProduct := getSingleCpeVendorProduct(a.Cpes)
		if out != "" && out != cpeVendorProduct {
			// there really shouldn't be multiple _different_ vendor products, we won't know the right one to use
			return ""
		}
		out = cpeVendorProduct
	}
	return out
}

func getSingleCpeVendorProduct(cpes []string) string {
	out := ""
	// if there are CPEs explicitly defined, use those
	for _, c := range cpes {
		val, _ := wfn.Parse(fmt.Sprintf("%v", c))
		if val == nil {
			continue
		}
		cpeVendorProduct := cpe.ToVendorProduct(val)
		if out != "" && out != cpeVendorProduct {
			// there really shouldn't be multiple _different_ cpes, we won't know the right one to use
			return ""
		}
		out = cpeVendorProduct
	}
	return out
}
