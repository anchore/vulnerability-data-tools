package search

import (
	"bytes"
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"slices"
	"strconv"
	"strings"

	"golang.org/x/exp/maps"

	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/termset"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

type Indexes struct {
	termsToProducts map[string]util.Set[*Product]
	allProducts     util.Set[*Product]
}

type Match struct {
	Product        *Product
	Score          float64
	Confidence     float64
	Count          int
	directCpeMatch bool
	Terms          termset.Set
}

func (i *Indexes) LookupProduct(searchTerms termset.Set) []Match {
	// get all products that Match _any_ term along with their Match percentage
	got := map[*Product]struct{}{}
	var matches []Match
	for term := range searchTerms {
		for p := range i.termsToProducts[term] {
			if p == nil {
				continue
			}
			if _, ok := got[p]; ok {
				continue
			}
			matchingTerms := termset.New()
			for t := range p.Weights {
				if searchTerms.Has(t) {
					matchingTerms.Add(t)
				}
			}
			if len(matchingTerms) > 0 {
				got[p] = struct{}{}
				matches = append(matches, Match{
					Product: p,
					Score:   getMatchScore(p, searchTerms),
					Terms:   matchingTerms,
				})
			}
		}
	}

	// order by score
	slices.SortFunc(matches, func(a, b Match) int {
		if a.Score == b.Score {
			return strings.Compare(a.Product.ID, b.Product.ID)
		}
		if a.Score < b.Score {
			return 1
		}
		return -1
	})

	setCount(matches)

	if len(matches) > 10 {
		matches = matches[0:10]
	}

	setConfidence(matches)

	// only return the top few matches
	if len(matches) > 5 {
		return matches[0:5]
	}

	return matches
}

func setCount(matches []Match) {
	for i := range matches {
		matches[i].Count = len(matches)
	}
}

func setConfidence(matches []Match) {
	totalScore := 0.
	for _, match := range matches {
		totalScore += match.Score
	}
	for i, match := range matches {
		matches[i].Confidence = 100 * match.Score / totalScore
	}
}

func (i *Indexes) associateTerm(term string, product *Product) {
	products := i.termsToProducts[term]
	if products == nil {
		products = util.Set[*Product]{}
		i.termsToProducts[term] = products
	}
	products.Add(product)
}

func (i *Indexes) termTotals() termset.Set {
	termCounts := termset.Set{}
	for p := range i.allProducts {
		termCounts.AddAll(p.Terms)
	}
	return termCounts
}

func (i *Indexes) removeProductTerm(p *Product, term string) {
	p.Terms.Remove(term)
	p.Weights.Remove(term)
	products := i.termsToProducts[term]
	if products != nil {
		products.Remove(p)
		if len(products) == 0 {
			delete(i.termsToProducts, term)
		}
	}
}

func (i *Indexes) Encode(writer io.Writer) error {
	csvLines := [][]string{{"product", "cves", "text"}}
	for p := range i.allProducts {
		txt := sortedTermPercent(p.Weights)
		cves := strings.Join(maps.Keys(p.Cves), " ")
		csvLines = append(csvLines, []string{p.ID, cves, txt})
	}
	w := csv.NewWriter(writer)
	return w.WriteAll(csvLines)
}

func (i *Indexes) Decode(reader io.Reader) error {
	i.termsToProducts = map[string]util.Set[*Product]{}
	i.allProducts = util.Set[*Product]{}

	r := csv.NewReader(reader)
	row, err := r.Read() // header
	for row, err = r.Read(); err == nil; row, err = r.Read() {
		cves := strings.Split(strings.TrimSpace(row[1]), " ")
		p := &Product{
			ID: row[0],
			//cpeTerms:   parseCpeTerms(row[0]),
			//cveMaxYear: maxCveYear(cves),
			Cves:    util.NewSet(cves...),
			Weights: parseWeights(row[2]),
			//Terms:      nil,
		}
		i.allProducts.Add(p)
		for term := range p.Weights {
			products := i.termsToProducts[term]
			if products == nil {
				products = util.Set[*Product]{}
				i.termsToProducts[term] = products
			}
			products.Add(p)
		}
	}
	if !errors.Is(err, io.EOF) {
		return err
	}
	return nil
}

func parseWeights(s string) termset.Set {
	out := termset.New()
	parts := strings.Split(strings.TrimSpace(s), " ")
	for i := 0; i < len(parts)-1; i += 2 {
		term := parts[i]
		weightStr := parts[i+1]
		weight, _ := strconv.ParseFloat(weightStr, 64)
		out[term] = weight
	}
	return out
}

func maxCveYear(cves []string) int {
	year := 1999
	for _, cve := range cves {
		yearStr := strings.Split(cve, "-")[1]
		v := int(util.LogGet(strconv.ParseInt(yearStr, 10, 64)))
		if v > year {
			year = v
		}
	}
	return year
}

func getMatchScore(p *Product, searchTerms termset.Set) float64 {
	count := 0.
	total := 0.
	for term := range p.Weights {
		if searchTerms.Has(term) {
			total += p.Weights[term]
			count++
		}
	}
	return total
}

func sortedTermPercent(terms termset.Set) string {
	type termPct struct {
		term string
		pct  float64
	}

	var sorted []termPct
	for term, pct := range terms {
		sorted = append(sorted, termPct{
			term,
			pct,
		})
	}
	slices.SortFunc(sorted, func(a, b termPct) int {
		if a.pct == b.pct {
			return strings.Compare(a.term, b.term)
		}
		// sort highest percentage first
		if a.pct < b.pct {
			return 1
		}
		return -1
	})
	buf := bytes.Buffer{}
	for _, term := range sorted {
		_, _ = fmt.Fprintf(&buf, "%s %f ", term.term, term.pct)
	}
	return buf.String()
}
