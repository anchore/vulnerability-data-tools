package search

import (
	"strings"

	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cve"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/termset"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

func BuildIndexes(records []cve.Rec) Indexes {
	l := Indexes{
		termsToProducts: map[string]util.Set[*Product]{},
		allProducts:     util.Set[*Product]{},
	}

	byID := map[string]*Product{}

	for _, r := range records {
		terms := parseTerms(r)

		// reset term counts to 1; counts are based on # of CVEs including the term,
		// not the number of times Terms appear
		terms.SetAll(1)

		// CPE Terms need to be considered, too
		cpeTerms := parseCpeTerms(r.ID)
		cpeTerms.SetAll(1)

		terms.AddAll(cpeTerms)

		//yearStr := strings.Split(r.Cve, "-")[1] // "cve-YEAR-number"
		//year := int(LogGet(strconv.ParseInt(yearStr, 10, 64)))

		prod := byID[r.ID]
		if prod == nil {
			prod = &Product{
				ID: r.ID,
				//cpeTerms:   cpeTerms,
				//cveMaxYear: year,
				Cves:  util.NewSet(r.Cve),
				Terms: terms,
			}
			byID[r.ID] = prod
			l.allProducts.Add(prod)
		} else {
			// add the cve
			prod.Cves.Add(r.Cve)
			prod.Terms.AddAll(terms)
		}

		// to associate terms
		for term := range terms {
			l.associateTerm(term, prod)
		}

		//if existing.cveMaxYear < year {
		//	existing.cveMaxYear = year
		//}
	}

	for _, p := range byID {
		// set Weights for all Terms to 1 initially
		p.Weights = termset.New(p.Terms.List()...)
	}

	// at this point, we have all the CPEs with all the text Terms used to describe them
	// including the number of times the Terms were used, but we need to reduce the number of Terms

	// normalize the term frequency based on the total number of products with each term -- e.g. if
	// only one Product has the term 3 times, and the term is only seen 3 times, this would be weighted to 1;
	// but if the term is seen 6 times, but only 3 times for this Product, it would be .5
	l = weightByOverallFrequency(l, .95)

	// weight the term based on the total number of entries per-Product -- e.g. if
	// every entry has the term "foo", this would get weighted to 1; but if 1 out of 10 has it, it would be .1
	l = weightByProductPercentage(l, .95)

	// weight the by latest year a term is seen
	l = weightByYear(l)

	// weight all Terms in the ID higher
	l = weightByIDTerms(l, 3)

	// only keep the top X Terms for each Product
	// l = keepTopTerms(l, 10)

	// remove Terms used in < X percentage of the Product descriptions describing a single Product
	l = removeLowWeightTerms(l, .1)

	// remove Terms used in other, completely textually unrelated products
	// l = removeTermsFromUnrelatedCPEs(l)

	// remove the top X Terms across all inputs
	// l = removeHighFrequencyTerms(l, 1000)

	return l
}

func parseCpeTerms(cpeParts string) termset.Set {
	terms := termset.New()
	for _, part := range strings.Split(cpeParts, ":") {
		if len(part) < 2 {
			continue
		}
		terms.AddAll(util.GetTextTerms(part))
	}
	return terms
}

func parseTerms(r cve.Rec) termset.Set {
	out := termset.Set{}
	for _, txt := range r.Text {
		out.AddAll(util.GetTextTerms(txt))
	}
	return out
}
