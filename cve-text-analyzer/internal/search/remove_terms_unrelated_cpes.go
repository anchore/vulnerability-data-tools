package search

//func removeTermsFromUnrelatedCPEs(l Indexes) Indexes {
//	// iterate over every Product, and divide term percentages on like Terms but unrelated products
//	for p1 := range l.allProducts {
//		// remove Terms from p1 that are present in p2, if they aren't part of the CPE string
//		for term := range p1.Weights {
//			termToProducts := l.termsToProducts[term]
//			for p2 := range termToProducts {
//				if isRelatedProduct(p1, p2) {
//					continue
//				}
//				if p2.cpeTerms.Has(term) {
//					continue
//				}
//
//				// reduce term weight
//				weight := p2.Weights[term]
//
//				// only remove Terms with low Weights
//				if weight < .01 {
//					// remove term from p2
//					l.removeProductTerm(p2, term)
//				}
//			}
//		}
//	}
//
//	return l
//}
//
//func isRelatedProduct(p1, p2 *Product) bool {
//	if p1.ID == p2.ID {
//		return true
//	}
//	p1Terms := parseCpeTerms(cpe.FromID(p1.ID))
//	p2Terms := parseCpeTerms(cpe.FromID(p2.ID))
//	// if any part of the CPE matches, e.g. a segment of the vendor or a segment of the Product
//	// this is considered "related" from a textual standpoint
//	for term := range p1Terms {
//		if p2Terms.Has(term) {
//			return true
//		}
//	}
//	// TODO -- some sort of letter similarity?
//	return false
//}
