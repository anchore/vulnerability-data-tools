package util

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	"unicode"
)

func Log(msgs ...any) {
	if len(msgs) < 1 {
		return
	}
	if msgs[0] == nil {
		return
	}
	msg, ok := msgs[0].(string)
	if ok && strings.Contains(msg, "%") {
		// use as format string
		msg = fmt.Sprintf(msg, msgs[1:]...)
	} else {
		msg = ""
		for _, m := range msgs {
			if len(msg) > 0 {
				msg += " "
			}
			msg += fmt.Sprintf("%v", m)
		}
	}
	_, _ = fmt.Fprintln(os.Stderr, msg)
}

// LogGet gets the value or panics on error, useful for (value, error) returns
func LogGet[T any](value T, err error) T {
	Log(err)
	return value
}

// Get gets the value or panics on error, useful for (value, error) returns
func Get[T any](value T, err error) T {
	PanicOnError(err)
	return value
}

// PanicOnError panics on error
func PanicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

// LogError logs if a non-nil error
func LogError(err error) {
	if err != nil {
		Log(err)
	}
}

// Whitespace includes nbsp (#160) considered to be a space character
var Whitespace = regexp.MustCompile(`[\s\xa0]+`)

var DisallowedChars = regexp.MustCompile(`[^\pL\pN]+`)

// Remove modifies the slice by removing the first matching element from it and returns the slice, for convenience
func Remove[T comparable](values []T, valueToRemove T) []T {
	if values == nil {
		return nil
	}
	for i, value := range values {
		if value == valueToRemove {
			return append(values[:i], values[i+1:]...)
		}
	}
	// wasn't found
	return values
}

// IsHashLike returns true for things that look like they could be hashes, e.g. a8b7s32cf932a or very long numbers
func IsHashLike(term string) bool {
	if len(term) < 6 {
		return false
	}

	digitCount := 0
	numberFollowsLetter := 0
	letterFollowsNumber := 0
	last := rune(term[0])
	for _, chr := range term[1:] {
		if unicode.IsDigit(last) && unicode.IsLetter(chr) {
			letterFollowsNumber++
		}
		if unicode.IsLetter(last) && unicode.IsDigit(chr) {
			numberFollowsLetter++
		}
		if unicode.IsDigit(chr) {
			digitCount++
		}
		last = chr
	}

	return digitCount > 6 || (numberFollowsLetter > 1 && letterFollowsNumber > 1)
}

func MergeAll[T any](everything [][]T) []T {
	var out []T
	for _, result := range everything {
		out = append(out, result...)
	}
	return out
}
