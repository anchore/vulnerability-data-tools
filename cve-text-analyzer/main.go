package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"runtime"
	"strings"

	"github.com/dustin/go-humanize"
	"github.com/facebookincubator/nvdtools/wfn"
	"github.com/google/uuid"
	"github.com/mitchellh/go-homedir"
	_ "modernc.org/sqlite"

	"github.com/anchore/go-sync"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cve"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/search"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

var (
	tmpDir       = ".tmp"
	cve5ListRepo = "https://github.com/CVEProject/cvelistV5.git"
	grypeDbRepo  = "https://github.com/anchore/grype-db.git"

	nvdDbFile         = path.Join(repoDir(grypeDbRepo), "data", "vunnel", "nvd", "results", "results.db")
	cveListDir        = path.Join(repoDir(cve5ListRepo), "cves")
	overrideOutputDir = path.Join(tmpDir, "overrides")

	timer = util.NewStopwatch()

	indexFile           = path.Join(tmpDir, "indexes.csv")
	cveCsvFile          = ""
	reIndex             = false
	format              = "overrides"
	confidenceCutoff    = 15
	showDescriptionsFor = ""
	showCvesWithoutCpes = false
)

func main() {
	defer printMemoryUsage()

	// parse CLI flags
	args := flags()
	cveIDs := args

	indexes := getIndexes()

	// if explicit action
	switch {
	case showDescriptionsFor != "":
		showDescriptions(showDescriptionsFor)
		return
	case showCvesWithoutCpes:
		printCvesWithoutCpes(os.Stdout)
		return
	}

	if cveCsvFile != "" {
		cveIDs = append(cveIDs, readFirstColumnFromCSVFile(cveCsvFile)...)
	}

	switch format {
	case "full":
		writeCveSearchResultFull(indexes, cveIDs, os.Stdout)
	case "csv":
		writeCveSearchResultCsv(indexes, cveIDs, os.Stdout)
	default:
		writeCveSearchResultOverrides(indexes, cveIDs)
	}
}

func writeCveSearchResultFull(indexes search.Indexes, cveIDs []string, out io.Writer) {
	for _, cveID := range cveIDs {
		searchText := searchTextFromCVE(cveListDir, cveID)
		searchTerms := util.GetTextTerms(searchText)

		matches := indexes.LookupProduct(searchTerms)

		_, _ = fmt.Fprintf(out, "SEARCH %s FULL TEXT: '%s':", cveID, searchText)
		_, _ = fmt.Fprintln(out)
		for _, m := range matches {
			_, _ = fmt.Fprintf(out, "  - %s (score: %.2f confidence: %.2f matches: %d)", validCPE(m.Product.Cpe), m.Score, m.Confidence, m.Count)
			_, _ = fmt.Fprintln(out)
		}

		_, _ = fmt.Fprintln(out)
		util.Log("lookup", cveID, "took:", timer.Lap())
	}
}

func writeCveSearchResultOverrides(indexes search.Indexes, cveIDs []string) {
	for _, cveID := range cveIDs {
		cveID = strings.ToUpper(cveID)

		searchText := searchTextFromCVE(cveListDir, cveID)
		searchTerms := util.GetTextTerms(searchText)

		matches := indexes.LookupProduct(searchTerms)
		matches = filterMatchesByConfidence(matches, confidenceCutoff)
		if len(matches) == 0 {
			util.Log("CVE %s NOT FOUND", cveID)
			continue
		}

		match := matches[0]

		overrideFile := path.Join(overrideOutputDir, cveFilePath(cveID))
		util.PanicOnError(os.MkdirAll(path.Dir(overrideFile), os.ModePerm))
		f := util.Get(os.OpenFile(overrideFile, os.O_RDWR|os.O_TRUNC|os.O_CREATE, os.ModePerm))
		writeOverride(f, searchText, match)
	}
}

func writeOverride(f io.Writer, searchText string, match search.Match) {
	cpe := validCPE(match.Product.Cpe)
	_ = util.Get(f.Write([]byte(fmt.Sprintf(`{
  "cve": {
    "configurations": [
      {
        "nodes": [
          {
            "cpeMatch": [
              {
				"searchTextUsed": "%s",
				"confidence": "%2.2f",
                "criteria": "%s",
                "matchCriteriaId": "%s",
                "vulnerable": true
              }
            ],
            "negate": false,
            "operator": "OR"
          }
        ]
      }
    ]
  }
}
`, formatSearchText(searchText), match.Confidence, cpe, uuid.New().String()))))
}

func formatSearchText(text string) string {
	return util.Whitespace.ReplaceAllString(text, " ")
}

func writeCveSearchResultCsv(indexes search.Indexes, cveIDs []string, writer io.Writer) {
	csvLines := [][]string{{"cve", "cpe", "confidence"}}
	for _, cveID := range cveIDs {
		searchText := searchTextFromCVE(cveListDir, cveID)
		searchTerms := util.GetTextTerms(searchText)

		matches := indexes.LookupProduct(searchTerms)
		matches = filterMatchesByConfidence(matches, confidenceCutoff)
		if len(matches) == 0 {
			csvLines = append(csvLines, []string{cveID, "NOT FOUND"})
			continue
		}
		match := matches[0]
		csvLines = append(csvLines, []string{cveID, validCPE(match.Product.Cpe), fmt.Sprintf("%2.2f", match.Confidence)})
	}

	w := csv.NewWriter(writer)
	util.PanicOnError(w.WriteAll(csvLines))
}

func validCPE(cpe string) string {
	var vendor, product, targetSW string
	parts := strings.Split(cpe, ":")
	vendor = parts[0]
	if len(parts) > 1 {
		product = parts[1]
	}
	if len(parts) > 2 {
		targetSW = parts[2]
	}
	out := wfn.Attributes{
		Part:      "",
		Vendor:    vendor,
		Product:   product,
		Version:   "",
		Update:    "",
		Edition:   "",
		SWEdition: "",
		TargetSW:  targetSW,
		TargetHW:  "",
		Other:     "",
		Language:  "",
	}.BindToFmtString()
	return out
}

func filterMatchesByConfidence(matches []search.Match, cutoff int) []search.Match {
	cut := float64(cutoff)
	var out []search.Match
	for _, match := range matches {
		if match.Confidence < cut {
			continue
		}
		out = append(out, match)
	}
	return out
}

func printMemoryUsage() {
	memStats := runtime.MemStats{}
	runtime.ReadMemStats(&memStats)
	util.Log("used memory:", humanize.Bytes(memStats.Alloc))
}

func flags() (args []string) {
	flag.StringVar(&indexFile, "indexes", indexFile, "index file")
	flag.BoolVar(&reIndex, "reindex", reIndex, "force reindexing")
	flag.BoolVar(&showCvesWithoutCpes, "show-cves-without-cpes", showCvesWithoutCpes, "shows all cves with no cpes associated")
	flag.StringVar(&nvdDbFile, "nvd-db", nvdDbFile, "nvd db file")
	flag.StringVar(&cveListDir, "cve-list-dir", cveListDir, "cve5 list data dir")
	flag.StringVar(&cveCsvFile, "cve-csv", cveCsvFile, "csv with a list of cves to identify")
	flag.StringVar(&format, "format", format, "output format (full, csv, override)")
	flag.StringVar(&showDescriptionsFor, "show-descriptions-for", showDescriptionsFor, "vendor:product to show all CVE descriptions")
	flag.IntVar(&confidenceCutoff, "confidence-cutoff", confidenceCutoff, "threshold to drop matches below confidence level")
	flag.Parse()

	// expand easier to use paths
	indexFile = util.Get(homedir.Expand(indexFile))
	nvdDbFile = util.Get(homedir.Expand(nvdDbFile))
	cveListDir = util.Get(homedir.Expand(cveListDir))
	cveCsvFile = util.Get(homedir.Expand(cveCsvFile))

	return flag.Args()
}

func getIndexes() (indexes search.Indexes) {
	f, err := os.Open(indexFile)

	if !reIndex && err == nil {
		// read prebuilt indexes
		indexes = readIndexes(f)
	} else {
		// otherwise, build indexes from source data
		indexes = createIndexes()
		f = util.Get(os.OpenFile(indexFile, os.O_RDWR|os.O_TRUNC|os.O_CREATE, os.ModePerm))
		util.PanicOnError(indexes.Encode(f))
	}
	return indexes
}

func createIndexes() search.Indexes {
	fetchData()

	indexes := processInputsToIndexes(sync.NewExecutor(-1), nvdDbFile, cveListDir)
	util.Log("process took:", timer.Lap())

	return indexes
}

func readIndexes(f *os.File) (indexes search.Indexes) {
	util.PanicOnError(indexes.Decode(f))
	return indexes
}

func repoDir(repo string) string {
	return path.Join(tmpDir, strings.TrimSuffix(path.Base(repo), ".git"))
}

func fetchData() {
	util.PanicOnError(os.MkdirAll(tmpDir, os.ModePerm))

	executor := sync.NewExecutor(-1)

	executor.Execute(func() {
		getLatestGrypeDbResults()
		util.Log("cloning grype-db took:", timer.Lap())
	})

	executor.Execute(func() {
		getLatestCveList()
		util.Log("cloning cve list took:", timer.Lap())
	})

	executor.Wait()
}

func getLatestCveList() {
	clone(cve5ListRepo)
}

func getLatestGrypeDbResults() {
	clone(grypeDbRepo)
	run(repoDir(grypeDbRepo), "make download-all-provider-cache")
}

func clone(repo string) {
	if _, err := os.ReadDir(repoDir(repo)); err == nil {
		run(repoDir(repo), "git pull")
	} else {
		run(tmpDir, "git clone --depth=1 "+repo)
	}
}

func run(dir, command string) {
	parts := strings.Split(command, " ")
	cmd := exec.Command(parts[0], parts[1:]...)
	cmd.Dir = dir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	util.PanicOnError(cmd.Run())
}

func cveFilePath(cve string) string {
	parts := strings.Split(cve, "-")
	year := parts[1]
	num := parts[2]
	subdir := fmt.Sprintf("%sxxx", num[0:len(num)-3])
	return path.Join(year, subdir, fmt.Sprintf("CVE-%s-%s.json", year, num))
}

func cveFileFullPath(cveListDir, cve string) string {
	return path.Join(cveListDir, cveFilePath(cve))
}

func searchTextFromCVE(cveListDir string, cveId string) string {
	file := cveFileFullPath(cveListDir, cveId)
	records := cve.ReadSingleVendorProducts(sync.NewExecutor(0), file)
	var text []string
	for _, r := range records {
		text = append(text, r.Text...)
	}
	return strings.Join(text, " ")
}

func showDescriptions(vendorProduct string) {
	rdr := csv.NewReader(util.Get(os.Open(indexFile)))
	// skip header row
	_, _ = rdr.Read() // skip headers
	for row, err := rdr.Read(); err == nil; row, err = rdr.Read() {
		if vendorProduct == row[0] {
			for _, cveId := range strings.Split(row[1], " ") {
				file := cveFileFullPath(cveListDir, cveId)
				records := cve.ReadSingleVendorProducts(sync.NewExecutor(0), file)
				var text []string
				for _, r := range records {
					text = append(text, r.Text...)
				}

				fmt.Printf("%s:", file)
				fmt.Println()
				for _, part := range text {
					fmt.Printf("    %s", part)
					fmt.Println()
				}
			}
			return
		}
	}
}
