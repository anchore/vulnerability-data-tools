import re

from typing import Any

UNKNOWN_VALUES =  {"", "-", "n/a", "unknown", "[unknown]", "(as-yet-unknown)", "unspecified", "as-yet-unknown"}
vendor_aliases = {
    "red hat": "redhat",
    "apache software foundation": "apache",
    "oracle corporation": "oracle",
    "f5 networks": "f5",
    "foxitsoftware": "foxit",
    "foxit_software": "foxit",
    "foxit software": "foxit",
    "microsoft corporation": "microsoft",
    "solidusio": "solidus",
    "nebulab": "solidus",
    "the node.js project": "node.js",
    "nodejs": "node.js",
}

def strip(value: str | None) -> str | None:
    if not value:
        return value
    
    value = value.strip()

    for suffix in {":", ",", "."}:
        if value.endswith(suffix):
            value = strip(value.removesuffix(suffix))

    if "," not in value and " and " not in value:
        if value.startswith("[") and value.endswith("]"):
            value = strip(value.strip("[]"))

        if value.startswith("(") and value.endswith(")"):
            value = strip(value.strip("()"))

        if value.startswith("*") and value.endswith("*"):
            value = strip(value.strip("*"))

    return value

def is_unknown(value: str | None) -> bool:
    if not value:
        return True
    
    if strip(value.lower()).strip("*").strip() in UNKNOWN_VALUES:
        return True
    
    return False


def normalize_vendor(vendor: str | None) -> str | None:
    vendor = normalize(vendor)
    if vendor:
        for suffix in [" inc", " co,. ltd", " co., ltd", " co,.ltd", " ltd", " llc", " co"]:
            if not vendor.endswith("& co"):
                if vendor.endswith(suffix):
                    vendor = normalize_vendor(vendor.removesuffix(suffix))

    if vendor:
        return vendor_aliases.get(vendor, vendor)
    
    return None


def normalize(value: str | None) -> str | None:
    if is_unknown(value):
        return None
    return strip(value.lower())


def normalize_collection_url(collection_url: str) -> str | None:
    collection_url = normalize(collection_url)

    if not collection_url:
        return None
    
    collection_url = collection_url.strip().removesuffix("/")
    collection_url = collection_url.removeprefix("http://").removeprefix("https://")

    if collection_url.startswith("repo1.maven.org"):
        collection_url = collection_url.replace("repo1.maven.org", "repo.maven.apache.org")

    if collection_url.startswith("pypi.python.org"):
        collection_url = collection_url.replace("pypi.python.org", "pypi.org")

    if collection_url.startswith("golang.org"):
        collection_url = collection_url.replace("golang.org", "pkg.go.dev")

    if collection_url.startswith("www.npmjs.com"):
        collection_url = collection_url.replace("www.npmjs.com", "registry.npmjs.org")

    if collection_url.startswith("repo.maven.apache.org/maven2") or collection_url == "repo.maven.apache.org":
        return "repo.maven.apache.org/maven2"

    if collection_url.startswith("pypi.org"):
        return "pypi.org"
    
    if collection_url.startswith("registry.npmjs.org"):
        return "registry.npmjs.org"
    
    return collection_url


def process_collection_url(collection_url: str, package_name: str) -> tuple[str | None, str | None]:
    if not collection_url:
        return collection_url, package_name
    
    collection_url = normalize_collection_url(collection_url)
    if package_name:
        collection_url = collection_url.removesuffix(package_name)
    else:
        if collection_url.startswith("wordpress.org/"):
            candidate = collection_url.split("/")[-1]
            if candidate not in ["plugins", "themes"]:
                package_name = candidate
                collection_url = collection_url.removesuffix(package_name)
                package_name = package_name.strip().replace(" ", "-")
        elif collection_url.startswith("github.com/"):
            components = collection_url.removeprefix("github.com/").split("/")
            if len(components) >= 2:
                collection_url = "github.com"
                package_name = f"{components[0]}/{components[1]}"

    collection_url = normalize_collection_url(collection_url)
    return collection_url, package_name


def cpes_from_collection_url(collection_url: str, package_name: str) -> list[str] | None:
    collection_url = normalize_collection_url(collection_url)
    package_name = normalize(package_name)

    if not collection_url or not package_name:
        return None
    
    if "repo.maven.apache.org/maven2" in collection_url or "repo1.maven.org" in collection_url:
        components = package_name.split(":")
        if len(components) == 2:
            return [f"cpe:2.3:a:{components[0]}:{components[1]}:*:*:*:*:*:*:*:*"]
        
    return None


def generate_candidates(value: str) -> list[str]:
    # Use a list because ordering is important (we want the original value to take precendence
    # over the additional generated ones)
    candidates = []
    value = normalize(value)

    if value:
        candidates.append(value)
        for s1, s2 in [(" ", "_"),(" ", "-"),("-", " "),("-", "_"),("_", " "),("_", "-")]:
            v = value.replace(s1, s2)
            if v not in candidates:
                candidates.append(v)

    return list(candidates)


def cpes_from_vendor_and_product(vendor, product) -> list[str]:
    vendors = generate_candidates(normalize_vendor(vendor))
    products = generate_candidates(product)
    cpes = []

    if vendors and products:
        for v in vendors:
            for p in products:
                cpes.append(f"cpe:2.3:a:{v}:{p}:*:*:*:*:*:*:*:*")

    return cpes

def clean_version(version: str | None) -> str | None:
    if not version:
        return version
    
    version = version.lower().removeprefix("version").strip()
    version = version.lstrip("=").strip()
    version = version.removeprefix("v").strip()

    if version == "0.0":
        version = "0"

    return version


def parse_cpe_5_version_info(v: dict[str, Any], solutions: set[str]) -> tuple[str, str, str, str]:
    version = normalize(v.get("version"))
    less_than = normalize(v.get("lessThan"))
    less_than_or_equal = normalize(v.get("lessThanOrEqual"))
    version_type = normalize(v.get("versionType", ""))

    if version and (not less_than and not less_than_or_equal):
        components = version.split(",")
        if len(components) <= 2:
            for c in components:
                c = normalize(c)
                if not c:
                    break

                if c.startswith(">="):
                    version = normalize(c.removeprefix(">="))
                elif c.startswith("<="):
                    less_than_or_equal = normalize(c.removeprefix("<="))
                elif c.startswith("<"):
                    less_than = normalize(c.removeprefix("<"))

            if less_than_or_equal and version.startswith("<=") or less_than and version.startswith("<"):
                version = None

    if version and ((less_than and version == less_than) or (less_than_or_equal and version == less_than_or_equal)):
        version = None

    if version:
        version = clean_version(version)

    if less_than:
        less_than = clean_version(less_than)

    if less_than_or_equal:
        less_than_or_equal = clean_version(less_than_or_equal)

    if less_than_or_equal and not less_than:
        for s in solutions:
            fix_version = re.search(r"Update to\s(.*)\sor a higher version.", s, re.IGNORECASE)

            if fix_version:
                less_than = fix_version.group(1)
                less_than_or_equal = None
                break

    return version, less_than, less_than_or_equal, version_type
