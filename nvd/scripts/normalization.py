from typing import Any

UNKNOWN_VALUES =  {"", "-", "n/a", "unknown", "[unknown]", "(as-yet-unknown)", "unspecified"}
vendor_aliases = {
    "red hat": "redhat",
    "apache software foundation": "apache",
    "oracle corporation": "oracle",
}

def strip(value: str | None) -> str | None:
    if not value:
        return value
    
    value = value.strip()

    for suffix in {":", ",", "."}:
        if value.endswith(suffix):
            value = strip(value.removesuffix(suffix))

    if "," not in value and " and " not in value:
        if value.startswith("[") and value.endswith("]"):
            value = strip(value.strip("[]"))

        if value.startswith("(") and value.endswith(")"):
            value = strip(value.strip("()"))

        if value.startswith("*") and value.endswith("*"):
            value = strip(value.strip("*"))

    return value

def is_unknown(value: str | None) -> bool:
    if not value:
        return True
    
    if strip(value.lower()).strip("*").strip() in UNKNOWN_VALUES:
        return True
    
    return False


def normalize_vendor(vendor: str | None) -> str | None:
    vendor = normalize(vendor)
    if vendor:
        for suffix in [" inc", " co,. ltd", " co., ltd", " co,.ltd", " ltd", " llc", " co"]:
            if not vendor.endswith("& co"):
                if vendor.endswith(suffix):
                    vendor = normalize_vendor(vendor.removesuffix(suffix))

    if vendor:
        return vendor_aliases.get(vendor, vendor)
    
    return None


def normalize(value: str | None) -> str | None:
    if is_unknown(value):
        return None
    return strip(value.lower())


def normalize_collection_url(collection_url: str) -> str | None:
    collection_url = normalize(collection_url)

    if not collection_url:
        return None
    
    collection_url = collection_url.removesuffix("/")
    collection_url = collection_url.removeprefix("http://")
    collection_url = collection_url.removeprefix("https://")
    collection_url = collection_url.replace("repo1.maven.org", "repo.maven.apache.org")
    collection_url = collection_url.replace("pypi.python.org", "pypi.org")

    if collection_url.startswith("repo.maven.apache.org/maven2/"):
        return "repo.maven.apache.org/maven2"

    if collection_url.startswith("pypi.org/"):
        return "pypi.org"
    
    return collection_url


def cpes_from_collection_url(collection_url: str, package_name: str) -> list[str] | None:
    collection_url = normalize_collection_url(collection_url)
    package_name = normalize(package_name)

    if not collection_url or not package_name:
        return None
    
    if "repo.maven.apache.org/maven2" in collection_url or "repo1.maven.org" in collection_url:
        components = package_name.split(":")
        if len(components) == 2:
            return [f"cpe:2.3:a:{components[0]}:{components[1]}:*:*:*:*:*:*:*:*"]
        
    return None


def generate_candidates(value: str) -> list[str]:
    # Use a list because ordering is important (we want the original value to take precendence
    # over the additional generated ones)
    candidates = []
    value = normalize(value)

    if value:
        candidates.append(value)
        for s1, s2 in [(" ", "_"),(" ", "-"),("-", " "),("-", "_"),("_", " "),("_", "-")]:
            v = value.replace(s1, s2)
            if v not in candidates:
                candidates.append(v)

    return list(candidates)


def cpes_from_vendor_and_product(vendor, product) -> list[str]:
    vendors = generate_candidates(normalize_vendor(vendor))
    products = generate_candidates(product)
    cpes = []

    if vendors and products:
        for v in vendors:
            for p in products:
                cpes.append(f"cpe:2.3:a:{v}:{p}:*:*:*:*:*:*:*:*")

    return cpes

def clean_version(version: str | None) -> str | None:
    if not version:
        return version
    
    version = version.lower().removeprefix("version").strip()
    version = version.lstrip("=").strip()
    version = version.removeprefix("v").strip()

    return version


def parse_cpe_5_version_info(v: dict[str, Any]) -> tuple[str, str, str, str]:
    version = normalize(v.get("version"))
    less_than = normalize(v.get("lessThan"))
    less_than_or_equal = normalize(v.get("lessThanOrEqual"))
    version_type = normalize(v.get("versionType", ""))

    if version and (not less_than and not less_than_or_equal):
        components = version.split(",")
        if len(components) <= 2:
            for c in components:
                c = normalize(c)
                if not c:
                    break

                if c.startswith(">="):
                    version = normalize(c.removeprefix(">="))
                elif c.startswith("<="):
                    less_than_or_equal = normalize(c.removeprefix("<="))
                elif c.startswith("<"):
                    less_than = normalize(c.removeprefix("<"))

            if less_than_or_equal and version.startswith("<=") or less_than and version.startswith("<"):
                version = None

    if version and ((less_than and version == less_than) or (less_than_or_equal and version == less_than_or_equal)):
        version = None

    if version:
        version = clean_version(version)

    if less_than:
        less_than = clean_version(less_than)

    if less_than_or_equal:
        less_than_or_equal = clean_version(less_than_or_equal)

    return version, less_than, less_than_or_equal, version_type
