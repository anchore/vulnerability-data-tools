import json
import logging
import os
from glob import glob
from typing import Any, Dict, TypeVar

from scripts.cpe_match import MatchCriteriaIdGenerator
from scripts.normalization import (
    parse_cpe_5_version_info,
    normalize_collection_url,
    generate_candidates,
    normalize_vendor,
    normalize,
)

MAX_BATCH_SIZE = 25

anchore_provider_metadata = {
    "orgId": "00000000-0000-4000-8000-000000000000",
    "shortName": "anchoreadp",
}

nvd_override_base_path = "nvd-data-overrides"
nvd_override_files = glob(os.path.join(nvd_override_base_path, "data/**/CVE-*.json"))
nvd_record_base_path = "national-vulnerability-database/data"
anchore_cve_data_enrichment_base_path = "cve-data-enrichment/data/anchore"
cve5_data_files = glob("cvelist-v5/cves/**/**/CVE-*.json")

wordpress_urls_indexed_by_cpe = {}

with open("data/cpe/curated/lookup/by_collection_url_and_package_name/application.json") as f:
    d = json.load(f)
    plugins = d["wordpress.org/plugins"]
    themes = d["wordpress.org/themes"]
    
    for package_name, cpes in plugins.items():
        package_name = package_name.strip().replace(" ", "-")
        for cpe in cpes:
            if cpe not in wordpress_urls_indexed_by_cpe:
                wordpress_urls_indexed_by_cpe[cpe] = set()

            wordpress_urls_indexed_by_cpe[cpe].add(f"https://wordpress.org/plugins/{package_name}")

    for package_name, cpes in themes.items():
        package_name = package_name.strip().replace(" ", "-")
        for cpe in cpes:
            if cpe not in wordpress_urls_indexed_by_cpe:
                wordpress_urls_indexed_by_cpe[cpe] = set()

            wordpress_urls_indexed_by_cpe[cpe].add(f"https://wordpress.org/themes/{package_name}")

def get_anchore_cve_enrichment_record(cve_id: str) -> dict | None:
    year = cve_id.split("-")[1]
    path = os.path.join(anchore_cve_data_enrichment_base_path, year, f"{cve_id}.json")

    if os.path.exists(path):
        with open(path) as fp:
            return json.load(fp)

    return None


def get_upstream_cve_record(cve_id: str) -> dict:
    matches = glob(f"cvelist-v5/cves/**/**/{cve_id}.json")

    if len(matches) != 1:
        raise RuntimeError(f"not single cve5 record for {cve_id}: found {matches}")

    with open(matches[0]) as fp:
        return json.load(fp)

def process_collection_url(collection_url: str, package_name: str) -> tuple[str | None, str | None]:
    if not collection_url:
        return collection_url, package_name
    
    collection_url = collection_url.strip("/")
    if package_name:
        collection_url = collection_url.removesuffix(package_name)
    else:
        candidate = collection_url.split("/")[-1]
        if candidate not in ["plugins", "themes"]:
            package_name = candidate
            collection_url = collection_url.removesuffix(package_name)
            package_name = package_name.strip().replace(" ", "-")

    collection_url = collection_url.strip("/")
    return collection_url, package_name

def process(override_record: dict):
    override_annotation = override_record["_annotation"]
    cve_id = override_annotation["cve_id"]
    override_cve = override_record["cve"]

    if not override_cve:
        logging.debug(f"skipping empty legacy override for {cve_id}")
        return

    anchore_enriched = get_anchore_cve_enrichment_record(cve_id)

    if anchore_enriched:
        logging.debug(
            f"skipping legacy override for {cve_id} as new Anchore enriched record already exists"
        )
        return

    upstream_cve_record = get_upstream_cve_record(cve_id)
    assigner = upstream_cve_record["cveMetadata"]["assignerShortName"].lower()

    if assigner != "mozilla":
        return

    cna_node = upstream_cve_record.get("containers", {}).get("cna", {})
    affected = cna_node["affected"]

    if len(affected) != 1:
        logging.warning(f"Multiple affected entries for {cve_id}")
        return

    collection_url = affected[0].get("collectionURL")
    package_name = affected[0].get("packageName")
    vendor = affected[0].get("vendor")
    product = affected[0].get("product")
    repo = affected[0].get("repo")

    collection_url, package_name = process_collection_url(collection_url, package_name)
    if not repo and collection_url and package_name:
        if collection_url == "https://wordpress.org/plugins":
            repo = f"https://plugins.svn.wordpress.org/{package_name}"
        elif collection_url == "https://wordpress.org/themes":
            repo = f"https://themes.svn.wordpress.org/{package_name}"

    observed_refs = set()
    additional_refs = []
    for ref in cna_node.get("references", []):
        observed_refs.add(ref["url"])

    for ref in override_annotation.get("triage_notes", {}).get("references", []):
        if ref not in observed_refs:
            additional_refs.append(
                {
                    "url": ref,
                }
            )
            observed_refs.add(ref)

    cpe_configs = override_cve.get("configurations", [])
    if len(cpe_configs) != 1:
        logging.warning(f"Multiple cpe configs for {cve_id}")
        return

    cpe_nodes = cpe_configs[0].get("nodes", [])
    if len(cpe_nodes) != 1:
        logging.warning(f"Multiple cpe nodes for {cve_id}")
        return

    cpes = set()
    versions = {}

    for m in cpe_nodes[0]["cpeMatch"]:
        vulnerable = m.get("vulnerable", False)
        criteria = m.get("criteria")
        version_start_including = m.get("versionStartIncluding")
        version_end_including = m.get("versionEndIncluding")
        version_end_excluding = m.get("versionEndExcluding")

        if vulnerable:
            status = "affected"
        else:
            status = "unaffected"

        if version_end_excluding:
            if not version_start_including or version_start_including == "0":
                version_start_including = "0"
                key = f"< {version_end_excluding}"
            else:
                key = f">= {version_start_including}, < {version_end_excluding}"

            if key not in versions:
                versions[key] = {
                    "version": version_start_including,
                    "lessThan": version_end_excluding,
                    "status": status,
                    "versionType": "custom",
                }
        elif version_end_including:
            if not version_start_including or version_start_including == "0":
                version_start_including = "0"
                key = f"<= {version_end_including}"
            else:
                key = f">= {version_start_including}, <= {version_end_including}"
            if key not in versions:
                versions[key] = {
                    "version": version_start_including,
                    "lessThanOrEqual": version_end_including,
                    "status": status,
                    "versionType": "custom",
                }
        else:
            cpe_components = criteria.split(":")
            version = cpe_components[4]
            key = f"= {version}"

            if key not in versions:
                versions[key] = {
                    "version": version,
                    "status": status,
                    "versionType": "custom",
                }

            cpe_components[4] = "*"
            criteria = ":".join(cpe_components)

        cpes.add(criteria)

    if not collection_url or not package_name:
        for cpe in cpes:
            candidates = wordpress_urls_indexed_by_cpe.get(cpe)
            
            if candidates and len(candidates) > 1:
                logging.warning(f"Need manual selection of collectionURL and package_name for {cve_id}: {list(candidates)}")
                break
            elif candidates:
                collection_url, package_name = process_collection_url(list(candidates)[0], None)
                break

    affected_entry = {}
    if collection_url:
        affected_entry["collectionURL"] = collection_url.strip()
    if package_name:
        affected_entry["packageName"] = package_name.strip()
    if vendor and vendor not in {"Unknown"}:
        affected_entry["vendor"] = vendor.strip()
    if product and product not in {"Unknown"}:
        affected_entry["product"] = product.strip()
    if repo:
        affected_entry["repo"] = repo.strip()

    affected_entry["cpes"] = sorted(list(cpes))
    affected_entry["versions"] = list(versions.values())

    enriched = {
        "additionalMetadata": {
            "cveId": cve_id,
            "reason": override_annotation["reason"],
            "cna": assigner,
            #"needs_review": True,
        },
        "adp": {
            "providerMetadata": anchore_provider_metadata,
            "affected": [
                affected_entry,
            ],
        },
    }

    if additional_refs:
        enriched["adp"]["references"] = additional_refs

    year = cve_id.split("-")[1]
    directory = os.path.join(anchore_cve_data_enrichment_base_path, year)
    if not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)

    file = os.path.join(directory, f"{cve_id}.json")
    with open(file, "w") as f:
        json.dump(enriched, f, sort_keys=True, indent=2, ensure_ascii=False)


if __name__ == "__main__":
    created = 0
    logging.basicConfig(level="WARNING")

    # Loop over all the CVE json files from cvelist-v5
    for override_file in nvd_override_files:
        with open(override_file) as fp:
            override_record = json.load(fp)

        process(override_record)

        # created_override = process(override_record)

        # if created_override:
        #     created += 1

        # # We only run as many time as defined by the batch size variable to avoid overwhelming whoever will review the findings
        # if created >= MAX_BATCH_SIZE:
        #     logging.warning("stopped processing as maximum created records reached")
        #     break
