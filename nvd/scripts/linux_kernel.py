import os
import re
import json
import logging
from glob import glob
from semantic_version import Version, SimpleSpec

published_cve_files = glob(
    "linux-kernel-vulns/cve/published/**/CVE-*.json", recursive=True
)


def get_major_minor(v: str) -> str | None:
    components = v.split(".")

    if len(components) == 3:
        return f"{components[0]}.{components[1]}"
    elif len(components) == 2:
        return v
    
    return None


def get_major_next_minor(v: str) -> str | None:
    major_minor = get_major_minor(v)

    if not major_minor:
        return None

    components = major_minor.split(".")
    next_minor = int(components[1]) + 1

    return f"{components[0]}.{next_minor}"

for cve_file in published_cve_files:
    with open(cve_file) as f:
        record = json.load(f)

    cve_id = record["cveMetadata"]["cveID"]
    additional_metadata = {
        "cna": "linux",
        "cveId": cve_id,
        "reason": "Synced Linux kernel data available from https://git.kernel.org/pub/scm/linux/security/vulns.git",
    }

    refs = []
    for ref in record["containers"]["cna"].get("references", []):
        refs.append(ref["url"])

    if refs:
        additional_metadata["references"] = sorted(refs)

    affected = record["containers"]["cna"].get("affected", [])
    if not affected:
        continue

    program_files = []
    process = True
    original_commit_for_fix = set()
    for a in affected:
        vendor = a["vendor"]
        product = a["product"]
        program_files = a.get("programFiles", [])
        if vendor.lower() != "linux" or product.lower() != "linux":
            logging.warning(
                f"{cve_id} - requires manual review due to unexpected vendor/product combination: vendor={vendor}, product={product}"
            )
            process = False
            break

        for v in a.get("versions", []):
            version_type = v.get("versionType")
            version = v.get("version")

            if version and version_type and version_type == "original_commit_for_fix":
                original_commit_for_fix.add(version)

    if not process:
        continue

    entry = {
        "cpes": ["cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"],
        "vendor": "Linux",
        "product": "Linux",
        "repo": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git",
    }

    if program_files:
        entry["programFiles"] = program_files

    # The versions in the cve json are difficult to interpret, so prefer parsing them from the email files
    email_file = cve_file.replace(".json", ".mbox")
    with open(email_file, "r") as f:
        email_lines = f.readlines()

    affected_lines = []
    ignore = True
    for line in email_lines:
        line = line.strip()
        if line.startswith("Affected and fixed versions"):
            ignore = False
            continue

        if line.startswith("=="):
            continue

        if ignore:
            continue

        if line.startswith("Please see https://www.kernel.org"):
            break

        if line:
            affected_lines.append(line)

    versions = []
    affected_ranges = set()
    starts = set()
    fixes = set()
    known_starting_versions = set()
    requires_manual_review = False
    is_first_fix = True
    next_range_start = None
    for a in affected_lines:
        m = re.match(
            r"^Issue introduced in (?P<introduced>[\d\.]+) with commit \w+ and fixed in (?P<fixed>[\d\.]+) with commit \w+$",
            a,
        )
        if m:
            g = m.groupdict()
            introduced = g["introduced"]
            if introduced in known_starting_versions:
                if next_range_start:
                    introduced = next_range_start

                requires_manual_review = True

            known_starting_versions.add(introduced)
            versions.append(
                {
                    "lessThan": g["fixed"],
                    "status": "affected",
                    "version": g["introduced"],
                    "versionType": "semver",
                }
            )
            is_first_fix = False
            next_range_start = get_major_next_minor(g["fixed"])
            continue

        m = re.match(
            r"^Issue introduced in (?P<introduced>[\d\.]+) with commit \w+$", a
        )
        if m:
            g = m.groupdict()
            introduced = g["introduced"]
            if introduced in known_starting_versions:
                requires_manual_review = True

            known_starting_versions.add(introduced)
            versions.append(
                {
                    "lessThanOrEqual": "*",
                    "status": "affected",
                    "version": g["introduced"],
                    "versionType": "semver",
                }
            )
            is_first_fix = False
            continue

        m = re.match(r"^Fixed in (?P<fixed>[\d\.]+) with commit \w+$", a)
        if m:
            g = m.groupdict()
            if is_first_fix:
                introduced = "0"
            else:
                components = g["fixed"].split(".")
                if len(components) == 3:
                    introduced = f"{components[0]}.{components[1]}"
                elif len(components) == 2:
                    # We won't create a record for the line where it was fixed prior to a release
                    if g["fixed"] in original_commit_for_fix:
                        continue

                    requires_manual_review = True
                    introduced = None
                else:
                    logging.warning(f"{cve_id} - {g['fixed']}")
                    requires_manual_review = True
                    introduced = None

            if introduced in known_starting_versions:
                requires_manual_review = True

            known_starting_versions.add(introduced)
            versions.append(
                {
                    "lessThan": g["fixed"],
                    "status": "affected",
                    "version": introduced,
                    "versionType": "semver",
                }
            )
            is_first_fix = False
            continue

        is_first_fix = False

    if versions:
        entry["versions"] = versions
        year = cve_id.split("-")[1]
        if requires_manual_review:
            continue
            additional_metadata["needsReview"] = True

        if not os.path.exists(f"cve-data-enrichment/data/anchore/{year}"):
            os.makedirs(f"cve-data-enrichment/data/anchore/{year}")

        with open(f"cve-data-enrichment/data/anchore/{year}/{cve_id}.json", "w") as f:
            json.dump(
                {
                    "additionalMetadata": additional_metadata,
                    "adp": {
                        "affected": [
                            entry,
                        ],
                        "providerMetadata": {
                            "orgId": "00000000-0000-4000-8000-000000000000",
                            "shortName": "anchoreadp",
                        },
                    },
                },
                f,
                indent=2,
                ensure_ascii=False,
                sort_keys=True,
            )
