import json
import logging
import os

from typing import Any

from glob import glob

nvd_record_base_path = ".tmp/national-vulnerability-database/data"

excluded_cves = {
    "CVE-2024-1139",
    "CVE-2024-35221",  # rubygems.org service
    "CVE-2021-33194", #Â Not affecting full golang stdlib
    "CVE-2024-21748", # icegram engage, not icegram express,
    "CVE-2008-1145", # In older ruby releases, webrick wasn't properly versioned, so the only way to handle this case is via full ruby runtime env versions
    "CVE-2022-39404", # mysql_installer not mysql
    "CVE-2024-7895", # power pack for beaver builder CPE seems like it may be incorrect for this one
    "CVE-2024-43948", # Should be wp_armour_extended

    # More precise than apache:tomcat
    "CVE-2023-44487",

    # More precise that apache:nifi 
    "CVE-2024-37389",

    # shouldn't need to specify ruby runtime, just the individual gem component
    "CVE-2020-10663",
    "CVE-2021-31799", 
}

ignored_vendors = {
    "siemens",
    "cisco",
    "netapp",
}

allowed_vendor_products: dict[str, set[str]] = {
    "nodejs": {"node.js"},
    "haxx": {"curl"},
    "oracle": {"mysql", "mysql_server", "mysql_cluster", "openjdk", "jdk", "jre", "java_se", "graalvm_for_jdk", "graalvm_enterprise", "graalvm"},
    "python": {"python"},
    "python_software_foundation": {"python"},
    "golang": {"go"},
    "redislabs": {"redis"},
    "redis": {"redis"},
    "helm": {"helm"},
    "ibm": {"java"},
    "busybox": {"busybox"},
    "kernel": {"util-linux"},
    "haproxy": {"haproxy"},
    "perl": {"perl"},
    "php": {"php"},
    "getcomposer": {"composer"},
    "apache": {"http_server"},
    "memcached": {"memcached"},
    "mozilla": {"firefox", "firefox_esr", "thunderbird"},
    "google": {"chrome"},
    "traefik": {"traefik"},
    "arangodb": {"arangodb"},
    "postgresql": {"postgresql"},
    "percona": {"percona_server", "xtradb_cluster", "xtrabackup"},
    "mariadb": {"mariadb"},
    "rust-lang": {"rust"},
    "rubylang": {"ruby"},
    "erlang": {"erlang\\/otp"},
    "dart": {"dart_software_development_kit"},
    "haskell": {"ghc", "cabal", "stack"},
    "hashicorp": {"consul", "vault", "terraform"},
    "f5": {"nginx"},
    "nginx": {"nginx"},
    "gnu": {"bash", "gcc", "gzip"},
    "openssl": {"openssl"},
    "treasuredata": {"fluent_bit"},
    "wp-cli": {"wp-cli"},
    "jenkins": {"jenkins"},
    "lighttpd": {"lighttpd"},
    "proftpd": {"proftpd"},
    "facebook": {"zstandard"},
    "tukaani": {"xz"},
    "zetetic": {"sqlcipher"},
    "jqlang": {"jq"},
}

def cpe_vendor_product_type(cpe: str) -> tuple[str, str, str]:
    components = cpe.split(":")
    vendor = components[3]
    product = components[4]
    cpe_type = components[2]

    return vendor, product, cpe_type

def vendor_product_index(affected: list[dict]) -> dict[str, set[str]]:
    index: dict[str, set[str]] = {}
    
    for a in affected:
        for cpe in a["cpes"]:
            vendor, product, _ = cpe_vendor_product_type(cpe)
            if vendor not in index:
                index[vendor] = set()

            index[vendor].add(product)

    return index

def get_existing_nvd_record(cve_id: str) -> dict[str, Any] | None:
    """
    Load an NVD record from the nvd_record_base_path location.

    Args:
        cve_id (str): A string containing a valid CVE ID

    Returns:
        dict: The parsed JSON for the NVD record

    By default the nvd_record_base_path location is
    ./national-vulnerability-database/data
    """
    cve_id = cve_id.upper()
    year = cve_id.split("-")[1]
    nvd_record_path = os.path.join(nvd_record_base_path, year, f"{cve_id}.json")
    if not os.path.exists(nvd_record_path):
        logging.debug(f"No NVD record for {cve_id}")
        return None

    with open(nvd_record_path, "r") as f:
        logging.debug(f"Loading current NVD record for {cve_id}")
        return json.load(f)


def only_for_mysql_cluster(description: str) -> bool:
    return description.startswith("Vulnerability in the MySQL Cluster product of Oracle MySQL (component: Cluster: General)")


for enriched_path in glob(
    "cve-data-enrichment/data/anchore/**/CVE-*.json"
):
    with open(enriched_path) as f:
        enriched = json.load(f)

    cve_id = enriched["additionalMetadata"]["cveId"]
    if cve_id in excluded_cves:
        continue

    affected_records = enriched["adp"]["affected"]
    index = vendor_product_index(affected_records)
    nvd_record = get_existing_nvd_record(cve_id)

    if not nvd_record or "cve" not in nvd_record:
        logging.warning(
            f"No NVD record currently exists for {cve_id}.  Have you pulled in latest"
        )
        continue

    if nvd_record["cve"]["vulnStatus"] in {"Rejected"}:
        continue

    nvd_configs = nvd_record["cve"].get("configurations")
    if not nvd_configs:
        continue

    description = nvd_record["cve"]["descriptions"][0]["value"]

    for c in nvd_configs:
        for n in c["nodes"]:
            for match in n["cpeMatch"]:
                cpe = match["criteria"] 
                vendor, product, cpe_type = cpe_vendor_product_type(cpe)

                if cpe_type != "a":
                    continue

                if vendor in ignored_vendors:
                    continue

                if vendor in index and product in index[vendor]:
                    continue

                if product in {"mysql", "mysql_server"} and only_for_mysql_cluster(description):
                    if "mysql_cluster" in index.get("oracle", set()):
                        continue
                    cpe = "cpe:2.3:a:oracle:mysql_cluster:*:*:*:*:*:*:*:*"

                if product in {"graalvm"} and "enterprise" in cpe:
                     if "graalvm_enterprise" in index.get("oracle", set()):
                         continue
                     cpe = "cpe:2.3:a:oracle:graalvm_enterprise:*:*:*:*:*:*:*:*"

                if vendor in {"apache"}:
                    continue

                if product not in allowed_vendor_products.get(vendor, set()):
                    continue

                print(f"{cve_id}: {cpe}")

#    with open(enriched_path, "w") as f:
#        json.dump(enriched, f, ensure_ascii=False, sort_keys=True, indent=2)
