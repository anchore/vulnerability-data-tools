import logging
import os

from glob import glob
from json import load, dump

from scripts.normalization import normalize, normalize_vendor, normalize_collection_url, cpes_from_collection_url

logging.basicConfig(level="INFO")

vendor_and_product_to_cpes: dict[str, dict[str, set[str]]] = {}
collection_url_and_package_to_cpes: dict[str, dict[str, set[str]]] = {}
product_to_cpes: dict[str, set[str]] = {}
all_vendors_and_products: dict[str, set[str]] = {}
all_products: set[str] = set()
all_collection_urls_and_packages: dict[str, set[str]] = {}
cves_with_no_mapping: dict[str, dict[str, str]] = {}

cve5_data_files = glob("cvelist-v5/cves/**/**/CVE-*.json")
# purl2cpe_cpe_files = glob("/Users/weston/github/westonsteimel/data/**/**/cpes.yaml")
# purl2cpe_purl_files = glob("/Users/weston/github/westonsteimel/data/**/**/purls.yaml")

vendor_aliases = {
    "red hat": "redhat",
    "apache software foundation": "apache",
    "oracle corporation": "oracle",
    "foxitsoftware": "foxit",
    "foxit_software": "foxit",
    "foxit software": "foxit",
    "microsoft corporation": "microsoft",
    "the node.js project": "node.js",
}

def lists_to_sets(obj):
    if isinstance(obj, list):
        return {lists_to_sets(v) for v in obj}
    elif isinstance(obj, dict):
        return {k: lists_to_sets(v) for k, v in obj.items()}
    return obj


def serialize_sets(obj):
    if isinstance(obj, set):
        return sorted(list(obj))

    return obj


class CPEPatternLookup:
    def __init__(self, path: str, load_existing: bool):
        self.path = path
        self.__cpe_types__: set[str] = {"application", "os", "hardware"}
        self.__lookup_by_collection_url_and_package_name__: dict[str, dict[str, dict[str, set[str]]]] = {}
        self.__lookup_by_vendor_and_product__: dict[str, dict[str, dict[str, set[str]]]] = {}
        self.__lookup_by_product__: dict[str, dict[str, set[str]]] = {}
        self.__load_data__(load_existing)
    
    def __load_data__(self, load_existing: bool):
        for type in self.__cpe_types__:
            if type not in self.__lookup_by_collection_url_and_package_name__:
                self.__lookup_by_collection_url_and_package_name__[type] = {}
            if type not in self.__lookup_by_vendor_and_product__:
                self.__lookup_by_vendor_and_product__[type] = {}
            if type not in self.__lookup_by_product__:
                self.__lookup_by_product__[type] = {}

            if load_existing:
                path = os.path.join(self.path, f"by_collection_url_and_package_name/{type}.json")
                if os.path.exists(path):
                    with open(path, "r") as f:
                        d = load(f)
                        for c, packages in d.items():
                            for p, cpes in packages.items():
                                self.update(collection_url=c, package_name=p, cpes=cpes)

                path = os.path.join(self.path, f"by_vendor_and_product/{type}.json")
                if os.path.exists(path):
                    with open(path, "r") as f:
                        d = load(f)
                        for v, products in d.items():
                            for p, cpes in products.items():
                                self.update(vendor=v, product=p, cpes=cpes)

                path = os.path.join(self.path, f"by_product/{type}.json")
                if os.path.exists(path):
                    with open(path, "r") as f:
                        d = load(f)
                        for p, cpes in d.items():
                            self.update(product=p, cpes=cpes)

    def persist(self, cpe_types: list[str] = None):
        if not cpe_types:
            cpe_types = self.__cpe_types__

        for type in cpe_types:
            path = os.path.join(self.path, f"by_collection_url_and_package_name/{type}.json")
            with open(path, "w") as f:
                dump(self.__lookup_by_collection_url_and_package_name__[type], f, indent=2, sort_keys=True, default=serialize_sets)

            path = os.path.join(self.path, f"by_vendor_and_product/{type}.json")
            with open(path, "w") as f:
                dump(self.__lookup_by_vendor_and_product__[type], f, indent=2, sort_keys=True, default=serialize_sets)

            path = os.path.join(self.path, f"by_product/{type}.json")
            with open(path, "w") as f:
                dump(self.__lookup_by_product__[type], f, indent=2, sort_keys=True, default=serialize_sets)

    def by_collection_url_and_package_name(self, collection_url: str, package_name: str, cpe_types: list[str] = None) -> set[str] | None:
        if not cpe_types:
            cpe_types = self.__cpe_types__
        r = set()
        collection_url = normalize_collection_url(collection_url)
        package_name = normalize(package_name)
        if not collection_url or not package_name:
            return None

        for type in cpe_types:
            t = self.__lookup_by_collection_url_and_package_name__[type].get(collection_url, {}).get(package_name)
            if t:
                r.update(t)
        if r:
            return r
        return None

    def by_vendor_and_product(self, vendor: str, product: str, cpe_types: list[str] = None) -> set[str] | None:
        if not cpe_types:
            cpe_types = self.__cpe_types__
        r = set()
        vendor = normalize_vendor(vendor)
        product = normalize(product)

        if not vendor or not product:
            return None

        for type in cpe_types:
            t = self.__lookup_by_vendor_and_product__[type].get(vendor, {}).get(product)
            if t:
                r.update(t)
        if r:
            return r
        return None        

    def by_product(self, product: str, cpe_types: list[str] = None) -> set[str] | None:
        if not cpe_types:
            cpe_types = self.__cpe_types__
        r = set()
        product = normalize(product)

        if not product:
            return None

        for type in cpe_types:
            t = self.__lookup_by_product__[type].get(product)
            if t:
                r.update(t)
        if r:
            return r
        return None  
    
    def __get_cpe_type__(self, cpe: str) -> str | None:
        if cpe.startswith("cpe:2.3:a:"):
            return "application"
        elif cpe.startswith("cpe:2.3:h:"):
             return "hardware"
        elif cpe.startswith("cpe:2.3:o:"):
            return "os"
        
        print(f"unknown cpe type for {cpe}")
        return None

    def update(
        self, 
        collection_url: str | None = None, 
        package_name: str | None = None, 
        vendor: str | None = None, 
        product: str | None = None, 
        cpes: set[str] | list[str] | str = None,
    ):
        collection_url = normalize_collection_url(collection_url)
        package_name = normalize(package_name)
        vendor = normalize_vendor(vendor)
        product = normalize(product)
        
        if not cpes:
            return
        
        if isinstance(cpes, str):
            cpes = set([cpes])

        for cpe in cpes:
            type = self.__get_cpe_type__(cpe)

            if not type:
                continue

            if collection_url and package_name:
                if collection_url not in self.__lookup_by_collection_url_and_package_name__[type]:
                    self.__lookup_by_collection_url_and_package_name__[type][collection_url] = {}

                if package_name not in self.__lookup_by_collection_url_and_package_name__[type][collection_url]:
                    self.__lookup_by_collection_url_and_package_name__[type][collection_url][package_name] = set()

                self.__lookup_by_collection_url_and_package_name__[type][collection_url][package_name].add(cpe)

            if vendor and product:
                if vendor not in self.__lookup_by_vendor_and_product__[type]:
                    self.__lookup_by_vendor_and_product__[type][vendor] = {}

                if product not in self.__lookup_by_vendor_and_product__[type][vendor]:
                    self.__lookup_by_vendor_and_product__[type][vendor][product] = set()

                self.__lookup_by_vendor_and_product__[type][vendor][product].add(cpe)
            elif product:
                if product not in self.__lookup_by_product__[type]:
                    self.__lookup_by_product__[type][product] = set()

                self.__lookup_by_product__[type][product].add(cpe)


class NVDRecordOverrides:
    def __init__(self, path: str = "nvd-overrides/data"):
        self.path = path
        self.__lookup__: dict[str, dict] = {}
        self.__load_data__()

    def __load_data__(self):
        override_files = glob(f"{self.path}/**/*.json", recursive=True)

        for file in override_files:
            with open(file, "r") as f:
                try:
                    cve_id = os.path.basename(file).removesuffix(".json")
                    c = load(f)
                    self.__lookup__[cve_id] = c
                except Exception:
                    logging.exception(f"failed to load NVD record override from {file}")

    def get(self, cve_id: str) -> dict | None:
        return self.__lookup__.get(cve_id)

nvd_overrides = NVDRecordOverrides()
curated_cpe_pattern_lookup = CPEPatternLookup(path="data/cpe/curated/lookup", load_existing=True)
generated_cpe_pattern_lookup = CPEPatternLookup(path="data/cpe/generated/lookup", load_existing=False)
final_generated_cpe_pattern_lookup = CPEPatternLookup(path="data/cpe/generated/lookup", load_existing=False)

for path in cve5_data_files:
    with open(path, "r") as f:
        record = load(f)

    cve_id = record.get("cveMetadata", {}).get("cveId")

    if not cve_id:
        continue

    nvd_override = nvd_overrides.get(cve_id=cve_id)
    nvd_entries = glob(f"national-vulnerability-database/data/**/{cve_id}.json")

    if not nvd_entries and not nvd_override:
        logging.warning(f"no nvd entry found for {cve_id}")
        continue

    with open(nvd_entries[0], "r") as f:
        nvd_entry = load(f)

    cna_node = record.get("containers", {}).get("cna", {})
    affected_entries = cna_node.get("affected", [])
    found_keys = False
    has_cpes = False

    vendors_and_products: list[dict[str, str]] = []
    products = set()
    collection_urls_and_packages: list[dict[str, str]] = []
    all_vulnerable_cpes = set()
    all_non_vulnerable_cpes = set()
    nvd_cpes_by_version_component: dict[str, set] = {}
    nvd_all_cpes = set()

    cpe_configurations = nvd_entry["cve"].get("configurations", [])
    if nvd_override:
        cpe_configurations = nvd_override["cve"].get("configurations", cpe_configurations)

    for c in cpe_configurations:
        for n in c.get("nodes", []):
            for m in n.get("cpeMatch", []):
                vulnerable = m.get("vulnerable", False)
                criteria = m.get("criteria")
                versions = set()
                for k in ["version", "versionStartExcluding", "versionStartIncluding", "versionEndExcluding", "versionEndIncluding"]:
                    v = m.get(k)
                    if v:
                        versions.add(v)

                if criteria and criteria.startswith("cpe:2.3"):
                    has_cpes = True
                    p = criteria.split(":")
                    versions.add(p[5])
                    p[5] = "*"
                    p[6] = "*"
                    cpe_vendor = normalize_vendor(p[3])
                    cpe_product = normalize(p[4])
                    normalized_cpe = ":".join(p)
                    nvd_all_cpes.add(normalized_cpe)

                    generated_cpe_pattern_lookup.update(vendor=cpe_vendor, product=cpe_product, cpes=[normalized_cpe])                        
                    for v in versions:
                        if v not in {"*", "-"}:
                            if v not in nvd_cpes_by_version_component:
                                nvd_cpes_by_version_component[v] = set()
                            nvd_cpes_by_version_component[v].add(normalized_cpe)

    for affected in affected_entries:
        vendor = normalize_vendor(affected.get("vendor"))
        product = normalize(affected.get("product"))
        collection_url = normalize_collection_url(affected.get("collectionURL"))
        package_name = normalize(affected.get("packageName", product))
        cpes = set()

        for cpe in affected.get("cpes", []):
            if cpe.startswith("cpe:2.3"): 
                components = cpe.split(":")
                if len(components) == 13:
                    components[5] = "*"
                    components[6] = "*"
                    cpes.add(":".join(components))

        found_specific_cpes_matching_version = False

        for av in affected.get("versions", []):
            for version_key in ["version", "lessThan", "lessThanOrEqual"]:
                version_value = normalize(av.get(version_key))
                if version_value and version_value in nvd_cpes_by_version_component:
                    found_specific_cpes_matching_version = True
                    cpes.update(nvd_cpes_by_version_component[version_value])

        if vendor == "go standard library":
            found_specific_cpes_matching_version = True
            cpes.add("cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*")

        if vendor == "google.golang.org/protobuf":
            found_specific_cpes_matching_version = True
            cpes.add("cpe:2.3:a:protobuf:protobuf:*:*:*:*:*:go:*:*")

        if not found_specific_cpes_matching_version:
            cpes = nvd_all_cpes

        if (not vendor and not product) and (not collection_url and not package_name):
            continue

        if collection_url and package_name:
            collection_urls_and_packages.append({
                "collection_url": collection_url,
                "package_name": package_name, 
            })

            if collection_url not in all_collection_urls_and_packages:
                all_collection_urls_and_packages[collection_url] = set()

            all_collection_urls_and_packages[collection_url].add(package_name)

            additional_cpes = cpes_from_collection_url(collection_url, package_name)
            if additional_cpes:
                curated = curated_cpe_pattern_lookup.by_collection_url_and_package_name(collection_url, package_name)
                if curated:
                    curated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=package_name, cpes=additional_cpes)
                else:
                    generated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=package_name, cpes=additional_cpes)

        if vendor and product:
            vendors_and_products.append({
                "vendor": vendor,
                "product": product, 
            })

            if vendor not in all_vendors_and_products:
                all_vendors_and_products[vendor] = set()

            all_vendors_and_products[vendor].add(product)
        elif product:
            products.add(product)
            all_products.add(product)
            if product.startswith("apache "):
                generated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=package_name, vendor="apache", product=product, cpes=cpes)
                generated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=package_name, vendor="apache", product=product.removeprefix("apache "), cpes=cpes)
                generated_cpe_pattern_lookup.update(product=product, cpes=cpes)

        generated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=package_name, vendor=vendor, product=product, cpes=cpes)

    is_rejected = record.get("cveMetadata", {}).get("state", "").upper() == "REJECTED"
    is_disputed = "disputed" in cna_node.get("tags", [])
    if not nvd_override and len(vendors_and_products) == 0 and len(collection_urls_and_packages) == 0 and len(products) == 0 and len(cpes) == 0 and not is_rejected and not is_disputed:
        logging.warning(f"no useable mapping data for {cve_id}")
        description = None
        for d in cna_node.get("descriptions", []):
            if d["lang"].lower() == "en":
                description = d["value"]

        cna = cna_node["providerMetadata"]["shortName"]
        cves_with_no_mapping[cve_id] = {
            "description": description,
            "cna": cna,
        }


no_vendor_and_product_cpe_mapping = {}
for vendor, products in all_vendors_and_products.items():
    for p in products:
        curated = curated_cpe_pattern_lookup.by_vendor_and_product(vendor, p)
        if curated:
            continue

        generated = generated_cpe_pattern_lookup.by_vendor_and_product(vendor, p)
        if generated:
            continue

        if vendor == "go standard library":
            generated_cpe_pattern_lookup.update(vendor=vendor, product=p, cpes=["cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*"])
            continue

        # if generated:
        #     for type in {"application"}:
        #         cpes = generated_cpe_pattern_lookup.by_vendor_and_product(vendor, p, cpe_types=[type])
        #         if cpes and len(cpes) == 1:
        #             curated_cpe_pattern_lookup.update(vendor=vendor, product=p, cpes=cpes)
        #     continue

        if vendor not in no_vendor_and_product_cpe_mapping:
            no_vendor_and_product_cpe_mapping[vendor] = set()
        no_vendor_and_product_cpe_mapping[vendor].add(p)

with open("data/no_vendor_and_product_cpe_mapping.json", "w") as f:
    dump(no_vendor_and_product_cpe_mapping, f, indent=2, sort_keys=True, default=serialize_sets)

def find_collection_url_cpes_from_vendor_lookup(collection_url: str, package_name: str) -> set[str]:
    cpes = set()
    collection_url = normalize_collection_url(collection_url)
    package_name = normalize(package_name)

    logging.debug(f"Looking up CPEs by product for collection_url={collection_url}, package_name={package_name}")

    if not collection_url or not package_name:
        return cpes

    for url, target_software in [("wordpress.org/plugins", "wordpress"), ("wordpress.org/themes", "wordpress")]:
        if collection_url == url: 
            candidates = curated_cpe_pattern_lookup.by_product(product=package_name)
            if not cpes:
                candidates = set()

            generated = generated_cpe_pattern_lookup.by_product(product=p)
            if generated:
                candidates.update(generated)

            for cpe in candidates:
                components = cpe.split(":")
                if len(components) == 13 and components[10] == target_software:
                    cpes.add(cpe)

    if package_name.startswith("google.golang.org/protobuf"):
        cpes.add("cpe:2.3:a:protobuf:protobuf:*:*:*:*:*:go:*:*")
    logging.debug(f"Found cpes: {cpes}")
    return cpes

no_collection_url_and_package_cpe_mapping = {}
for collection_url, packages in all_collection_urls_and_packages.items():
    for p in packages:
        curated = curated_cpe_pattern_lookup.by_collection_url_and_package_name(collection_url, p)
        if curated:
            continue

        generated = generated_cpe_pattern_lookup.by_collection_url_and_package_name(collection_url, p)
        # if generated:
        #     for type in {"application"}:
        #         cpes = generated_cpe_pattern_lookup.by_collection_url_and_package_name(collection_url, p, cpe_types=[type])
        #         if cpes and len(cpes) == 1:
        #            curated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=p, cpes=cpes)
        #     continue
        if generated:
            continue

        cpes_from_product = find_collection_url_cpes_from_vendor_lookup(collection_url, p)
        if len(cpes_from_product) > 0:
            generated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=p, cpes=cpes_from_product)
            continue

        if collection_url not in no_collection_url_and_package_cpe_mapping:
            no_collection_url_and_package_cpe_mapping[collection_url] = set()
        no_collection_url_and_package_cpe_mapping[collection_url].add(p)

# for product in all_products:
#     curated = curated_cpe_pattern_lookup.by_product(product)
#     if curated:
#         continue

#     generated = generated_cpe_pattern_lookup.by_product(product)
#     if generated:
#         for type in {"application"}:
#             cpes = generated_cpe_pattern_lookup.by_product(product, cpe_types=[type])
#             if cpes and len(cpes) == 1:
#                 curated_cpe_pattern_lookup.update(product=product, cpes=cpes)

with open("data/cves_with_no_mapping.json", "w") as f:
    dump(cves_with_no_mapping, f, indent=2, sort_keys=True)

curated_cpe_pattern_lookup.persist()

def filter_vendor_cpes(cpes: set[str], vendor) -> set[str]:
    r = set()
    vendor = normalize_vendor(vendor)

    for cpe in cpes:
        components = cpe.split(":")
        cpe_vendor = normalize_vendor(components[3])
        if cpe_vendor == "redhat" and "redhat" not in vendor:
            continue
        if cpe_vendor == "oracle" and "oracle" not in vendor:
            continue
        if vendor == "apache" and "apache" not in cpe:
            continue

        r.add(cpe)

    return r

def filter_application_cpes_only(cpes: set[str]) -> set[str]:
    r = set()

    for c in cpes:
        if c.startswith("cpe:2.3:a:"):
            r.add(c)

    return r

for type in generated_cpe_pattern_lookup.__cpe_types__:
    for vendor, products in generated_cpe_pattern_lookup.__lookup_by_vendor_and_product__[type].items():
        for p, cpes in products.items():
            if not curated_cpe_pattern_lookup.by_vendor_and_product(vendor, p):
                cpes = filter_application_cpes_only(cpes)
                cpes = filter_vendor_cpes(cpes=cpes, vendor=vendor)
                if len(cpes) > 10:
                    logging.warning(f"Throwing out CPE lookup for vendor={vendor!r}, product={p!r} due to too many candidates: {cpes!r}")
                    if vendor not in no_vendor_and_product_cpe_mapping:
                        no_vendor_and_product_cpe_mapping[vendor] = set()
                    no_vendor_and_product_cpe_mapping[vendor].add(p)
                    continue
                final_generated_cpe_pattern_lookup.update(vendor=vendor, product=p, cpes=cpes)

    for collection_url, packages in generated_cpe_pattern_lookup.__lookup_by_collection_url_and_package_name__[type].items():
        for p, cpes in packages.items():
            if not curated_cpe_pattern_lookup.by_collection_url_and_package_name(collection_url, p):
                cpes = filter_application_cpes_only(cpes)
                if len(cpes) > 10:
                    cpes = filter_vendor_cpes(cpes=cpes, vendor=collection_url)
                    if len(cpes) > 10:
                        logging.warning(f"Throwing out CPE lookup for collection_url={collection_url!r}, package={p!r} due to too many candidates: {cpes!r}")
                        if collection_url not in no_collection_url_and_package_cpe_mapping:
                            no_collection_url_and_package_cpe_mapping[collection_url] = set()
                        no_collection_url_and_package_cpe_mapping[collection_url].add(p)
                        continue
                final_generated_cpe_pattern_lookup.update(collection_url=collection_url, package_name=p, cpes=cpes)

    for product, cpes in generated_cpe_pattern_lookup.__lookup_by_product__[type].items():
        if not curated_cpe_pattern_lookup.by_product(product):
            cpes = filter_application_cpes_only(cpes)
            if product.startswith("apache "):
                cpes = filter_vendor_cpes(cpes=cpes, vendor="apache")
            if len(cpes) > 10:
                logging.warning(f"Throwing out CPE lookup for product={product!r} due to too many candidates: {cpes!r}")
                continue
            final_generated_cpe_pattern_lookup.update(product=product, cpes=cpes)

final_generated_cpe_pattern_lookup.persist(cpe_types=["application"])

with open("data/no_vendor_and_product_cpe_mapping.json", "w") as f:
    dump(no_vendor_and_product_cpe_mapping, f, indent=2, sort_keys=True, default=serialize_sets)

with open("data/no_collection_url_and_package_to_cpes.json", "w") as f:
    dump(no_collection_url_and_package_cpe_mapping, f, indent=2, sort_keys=True, default=serialize_sets)